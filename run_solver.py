#!/usr/bin/env python3
"""Run SAT4J with a hard timeout and immediately summarize the best model."""
from __future__ import annotations
import argparse
import signal
import subprocess
import sys
import time
from pathlib import Path


def parse_args() -> argparse.Namespace:
    ap = argparse.ArgumentParser(
        description="Wrapper around SAT4J with a wall-clock timeout and automatic model analysis",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
    )
    ap.add_argument("--opb", default="schedule.opb", type=Path, help="Path to the .opb file generated by the encoder")
    ap.add_argument("--core-jar", default="org.ow2.sat4j.core-2.3.6.jar", type=Path, help="Path to sat4j core jar")
    ap.add_argument("--pb-jar", default="org.ow2.sat4j.pb-2.3.6.jar", type=Path, help="Path to sat4j pb jar")
    ap.add_argument("--main-class", default="org.sat4j.pb.LanceurPseudo2007", help="Solver entry point")
    ap.add_argument("--timeout", type=int, default=120, help="Time limit in seconds (default: 120s)")
    ap.add_argument("--log", type=Path, default=Path("solver.log"), help="Where to store solver stdout")
    ap.add_argument(
        "--interrupt-grace",
        type=int,
        default=10,
        help="Seconds to wait after delivering SIGINT before force-killing the solver",
    )
    ap.add_argument("--models-out", type=Path, default=Path("models.txt"), help="Path that will receive the extracted v-lines")
    ap.add_argument("--varmap", type=Path, default=Path("varmap.json"), help="varmap produced by the encoder")
    ap.add_argument("--components", type=Path, default=Path("components_all.csv"), help="components table used for encoding")
    ap.add_argument(
        "--metric",
        choices=["count", "taskcount", "effort"],
        default="effort",
        help="Load metric forwarded to consume_saved_models.py",
    )
    ap.add_argument("--assigned-out", type=Path, default=Path("assigned_optimal.csv"))
    ap.add_argument("--models-summary", type=Path, default=Path("models_summary.csv"))
    ap.add_argument("--loads-out", type=Path, default=Path("loads_by_person.csv"))
    ap.add_argument("--penalties-out", type=Path, default=Path("penalties_activated.csv"))
    ap.add_argument("--cooldown-debug-out", type=Path, default=Path("cooldown_debug_by_pf.csv"))
    ap.add_argument("--plots-bars", type=Path, default=Path("fairness_plots_bars.png"))
    ap.add_argument("--plots-lorenz", type=Path, default=Path("fairness_plots_lorenz.png"))
    ap.add_argument(
        "--consume-script",
        type=Path,
        default=Path(__file__).with_name("consume_saved_models.py"),
        help="Path to consume_saved_models.py",
    )
    ap.add_argument("--skip-consume", action="store_true", help="Skip running consume_saved_models.py even if a model exists")
    return ap.parse_args()


def extract_models(stdout: str) -> list[str]:
    models: list[str] = []
    for line in stdout.splitlines():
        stripped = line.strip()
        if not stripped:
            continue
        if stripped.lower().startswith("v "):
            models.append(stripped)
    return models


def run_consumer(args: argparse.Namespace, models_path: Path) -> None:
    consume_cmd = [
        sys.executable,
        str(args.consume_script),
        "--models",
        str(models_path),
        "--varmap",
        str(args.varmap),
        "--components",
        str(args.components),
        "--metric",
        args.metric,
        "--assigned-out",
        str(args.assigned_out),
        "--models-out",
        str(args.models_summary),
        "--loads-out",
        str(args.loads_out),
        "--penalties-out",
        str(args.penalties_out),
        "--cooldown-debug-out",
        str(args.cooldown_debug_out),
        "--plots-bars",
        str(args.plots_bars),
        "--plots-lorenz",
        str(args.plots_lorenz),
    ]
    print("[run_solver] Running consumer:", " ".join(str(c) for c in consume_cmd))
    subprocess.run(consume_cmd, check=True)


def main() -> None:
    args = parse_args()
    classpath = f"{args.core_jar}:{args.pb_jar}"
    cmd = [
        "java",
        "-cp",
        classpath,
        args.main_class,
        str(args.opb),
    ]

    started = time.time()
    print("Running:", " ".join(str(c) for c in cmd), file=sys.stderr)
    log_path = Path(args.log)
    log_path.parent.mkdir(parents=True, exist_ok=True)

    with subprocess.Popen(
        cmd,
        stdout=subprocess.PIPE,
        stderr=subprocess.STDOUT,
        text=True,
        bufsize=1,
        universal_newlines=True,
    ) as proc:
        timed_out = False
        try:
            stdout, _ = proc.communicate(timeout=args.timeout)
        except subprocess.TimeoutExpired:
            timed_out = True
            print(
                f"[run_solver] Timeout after {args.timeout}s – sending SIGINT to request best-so-far model...",
                file=sys.stderr,
            )
            proc.send_signal(signal.SIGINT)
            try:
                stdout, _ = proc.communicate(timeout=args.interrupt_grace)
            except subprocess.TimeoutExpired:
                print(
                    f"[run_solver] Solver ignored SIGINT for {args.interrupt_grace}s – killing process.",
                    file=sys.stderr,
                )
                proc.kill()
                stdout, _ = proc.communicate()
        finally:
            duration = time.time() - started

    log_path.write_text(stdout, encoding="utf-8")
    print(stdout, end="")
    exit_code = proc.returncode if proc.returncode is not None else 1
    if timed_out:
        print(
            f"[run_solver] Timed out after {args.timeout}s (elapsed {duration:.1f}s). "
            f"Partial output saved to {log_path}",
            file=sys.stderr,
        )
        exit_code = 124

    print(f"[run_solver] Solver finished in {duration:.1f}s (rc={exit_code}). Log: {log_path}")

    models = extract_models(stdout)
    if models:
        models_path = Path(args.models_out)
        models_path.write_text("\n".join(models) + "\n", encoding="utf-8")
        print(f"[run_solver] Saved {len(models)} model lines to {models_path}")
        if not args.skip_consume:
            try:
                run_consumer(args, models_path)
            except subprocess.CalledProcessError as exc:
                print(f"[run_solver] consume_saved_models.py failed: {exc}", file=sys.stderr)
                raise SystemExit(exc.returncode)
    else:
        print("[run_solver] No 'v ...' model lines detected; skipping consumer.", file=sys.stderr)

    raise SystemExit(exit_code)


if __name__ == "__main__":
    main()
