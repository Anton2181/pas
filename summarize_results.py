#!/usr/bin/env python3
"""Summarize the latest solver artifacts.

Reads the CSVs generated by ``run_solver.py`` / ``consume_saved_models.py``
and prints a concise report so you can answer "what's our current best?"
without opening multiple spreadsheets.
"""
from __future__ import annotations

import argparse
import csv
from collections import Counter
from pathlib import Path
from typing import Dict, Iterable, List, Optional

Row = Dict[str, str]


def _load_csv(path: Path) -> List[Row]:
    if not path.exists():
        raise FileNotFoundError(f"Missing required file: {path}")
    with path.open(newline="", encoding="utf-8") as handle:
        return list(csv.DictReader(handle))


def _parse_float(value: str) -> Optional[float]:
    if value is None or value == "":
        return None
    try:
        return float(value)
    except ValueError:
        return None


def choose_best_model(rows: Iterable[Row]) -> Optional[Row]:
    candidates: List[Row] = list(rows)
    if not candidates:
        return None
    # Prefer the row with the smallest objective when available; otherwise
    # fall back to the first row (models are appended in solver order).
    best_row = min(
        candidates,
        key=lambda row: (_parse_float(row.get("objective"))
                         if row.get("objective") not in (None, "") else float("inf"))
    )
    if best_row.get("objective") in (None, ""):
        return candidates[0]
    return best_row


def summarize_models(path: Path) -> str:
    rows = _load_csv(path)
    best = choose_best_model(rows)
    if not best:
        return "No models recorded yet."

    parts = [
        f"Best model idx: {best.get('idx', 'unknown')}",
    ]
    objective = best.get("objective")
    if objective:
        parts.append(f"objective = {objective}")
    parts.append(
        "assignments = {num_assignments} (max load {max_load}, min load {min_load})".format(
            num_assignments=best.get("num_assignments", "?"),
            max_load=best.get("max_load", "?"),
            min_load=best.get("min_load", "?"),
        )
    )

    penalty_keys = [
        "n_CooldownPRI",
        "n_CooldownNON",
        "n_CooldownGeoPRI",
        "n_CooldownGeoNON",
        "n_CooldownStreak",
        "n_RepeatOverPRI",
        "n_RepeatOverNON",
        "n_BothFallback",
        "n_PreferredMiss",
        "n_OneTaskDay",
        "n_TwoDaySoft",
        "n_DeprioritizedPair",
    ]
    penalties = [
        f"{key.replace('n_', '')}={best.get(key, '0')}" for key in penalty_keys if key in best
    ]
    parts.append("penalties: " + ", ".join(penalties))
    return "\n".join(parts)


def summarize_penalties(path: Path, top_n: int) -> str:
    rows = _load_csv(path)
    if not rows:
        return "No penalty activations recorded yet."
    counter = Counter(row.get("Category", "Unknown") or "Unknown" for row in rows)
    total = sum(counter.values())
    pieces = [f"Penalty activations: {total} total"]
    for category, count in counter.most_common(top_n):
        pieces.append(f"  - {category}: {count}")
    if len(counter) > top_n:
        pieces.append(f"  â€¦ {len(counter) - top_n} additional categories")
    return "\n".join(pieces)


def summarize_loads(path: Path, top_n: int) -> str:
    rows = _load_csv(path)
    if not rows:
        return "No load data available."
    try:
        sorted_rows = sorted(
            rows,
            key=lambda row: _parse_float(row.get("TotalLoad", "0")) or 0.0,
            reverse=True,
        )
    except KeyError:
        return "Unexpected schema for loads file."

    top_lines = [
        f"  - {row['Person']}: {row.get('TotalLoad', '?')}" for row in sorted_rows[:top_n]
    ]
    bottom_lines = [
        f"  - {row['Person']}: {row.get('TotalLoad', '?')}" for row in sorted_rows[-top_n:]
    ]
    return "\n".join([
        "Top loads:",
        *top_lines,
        "Bottom loads:",
        *bottom_lines,
    ])


def summarize_assignment(path: Path, top_n: int) -> Optional[str]:
    if path is None:
        return None
    if not path.exists():
        return None
    rows = _load_csv(path)
    if not rows:
        return None
    header = rows[0].keys()
    person_field = next((field for field in ("Person", "Assigned To", "AssignedTo") if field in header), None)
    if not person_field:
        return None
    by_person = Counter(row.get(person_field, "Unknown") or "Unknown" for row in rows)
    pieces = ["People with the most assignments:"]
    for person, count in by_person.most_common(top_n):
        pieces.append(f"  - {person}: {count}")
    return "\n".join(pieces)


def main() -> None:
    parser = argparse.ArgumentParser(description="Summarize solver outputs.")
    parser.add_argument("--models", type=Path, default=Path("models_summary.csv"),
                        help="Path to models_summary.csv")
    parser.add_argument("--penalties", type=Path, default=Path("penalties_activated.csv"),
                        help="Path to penalties_activated.csv")
    parser.add_argument("--loads", type=Path, default=Path("loads_by_person.csv"),
                        help="Path to loads_by_person.csv")
    parser.add_argument("--assigned", type=Path, default=Path("assigned_optimal.csv"),
                        help="Path to assigned_optimal.csv (optional)")
    parser.add_argument("--top", type=int, default=5,
                        help="How many entries to show for top/bottom summaries")
    args = parser.parse_args()

    print(summarize_models(args.models))
    print()
    print(summarize_penalties(args.penalties, args.top))
    print()
    print(summarize_loads(args.loads, args.top))
    assignment_summary = summarize_assignment(args.assigned, args.top)
    if assignment_summary:
        print()
        print(assignment_summary)


if __name__ == "__main__":
    main()
